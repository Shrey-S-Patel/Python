[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "greeting",
        "kind": 5,
        "importPath": "Lesson 1.kemCho",
        "description": "Lesson 1.kemCho",
        "peekOfCode": "greeting = 'Kem Cho?'\nprint(greeting)",
        "detail": "Lesson 1.kemCho",
        "documentation": {}
    },
    {
        "label": "value",
        "kind": 5,
        "importPath": "Lesson 10.example",
        "description": "Lesson 10.example",
        "peekOfCode": "value = True\ncount = 0\n# This statement assumes that while value is true or exists, it will execute.\nwhile value:\n    count += 1\n    print(count)\n    if(count == 5):\n        break\n    else:\n        value = False # Or use a zero to do the same thing.",
        "detail": "Lesson 10.example",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "Lesson 10.example",
        "description": "Lesson 10.example",
        "peekOfCode": "count = 0\n# This statement assumes that while value is true or exists, it will execute.\nwhile value:\n    count += 1\n    print(count)\n    if(count == 5):\n        break\n    else:\n        value = False # Or use a zero to do the same thing.\n        continue",
        "detail": "Lesson 10.example",
        "documentation": {}
    },
    {
        "label": "add_one",
        "kind": 2,
        "importPath": "Lesson 10.recursion",
        "description": "Lesson 10.recursion",
        "peekOfCode": "def add_one(num):\n    if (num >= 9 ):\n        return num + 1\n    total = num + 1\n    print(total)\n    return add_one(total) # This return keyword is absolutely essential for recursion or else it returns a none.\n# To see the output of 10 we first need a variable we can print.\noutput = add_one(0)\nprint(\"Your output is \" + str(output))",
        "detail": "Lesson 10.recursion",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "Lesson 10.recursion",
        "description": "Lesson 10.recursion",
        "peekOfCode": "output = add_one(0)\nprint(\"Your output is \" + str(output))",
        "detail": "Lesson 10.recursion",
        "documentation": {}
    },
    {
        "label": "play_rps",
        "kind": 2,
        "importPath": "Lesson 10.rps3",
        "description": "Lesson 10.rps3",
        "peekOfCode": "def play_rps():\n    # Constants are always in CAPS\n    class RPS(Enum):\n        ROCK = 1\n        PAPER = 2\n        SCISSORS = 3\n    # Now we start coding the Rock-Paper-Scissors game.\n    print(\"\")\n    player_choice = input(\"Enter...\\n1 for Rock 🪨, \\n2 for Paper 📄, \\nor \\n3 for Scissors ✂️:\\n\\n\")\n    # Let's introduce some control-flow statements",
        "detail": "Lesson 10.rps3",
        "documentation": {}
    },
    {
        "label": "play_rps",
        "kind": 2,
        "importPath": "Lesson 11.rps4",
        "description": "Lesson 11.rps4",
        "peekOfCode": "def play_rps():\n    # Constants are always in CAPS\n    class RPS(Enum):\n        ROCK = 1\n        PAPER = 2\n        SCISSORS = 3\n    # Now we start coding the Rock-Paper-Scissors game.\n    print(\"\")\n    player_choice = input(\"Enter...\\n1 for Rock 🪨, \\n2 for Paper 📄, \\nor \\n3 for Scissors ✂️:\\n\\n\")\n    # Let's introduce some control-flow statements",
        "detail": "Lesson 11.rps4",
        "documentation": {}
    },
    {
        "label": "game_count",
        "kind": 5,
        "importPath": "Lesson 11.rps4",
        "description": "Lesson 11.rps4",
        "peekOfCode": "game_count = 0\ndef play_rps():\n    # Constants are always in CAPS\n    class RPS(Enum):\n        ROCK = 1\n        PAPER = 2\n        SCISSORS = 3\n    # Now we start coding the Rock-Paper-Scissors game.\n    print(\"\")\n    player_choice = input(\"Enter...\\n1 for Rock 🪨, \\n2 for Paper 📄, \\nor \\n3 for Scissors ✂️:\\n\\n\")",
        "detail": "Lesson 11.rps4",
        "documentation": {}
    },
    {
        "label": "greeting",
        "kind": 2,
        "importPath": "Lesson 11.scope",
        "description": "Lesson 11.scope",
        "peekOfCode": "def greeting(name):\n    color = \"Blue\"\n    # Local scope.\n    # In this case color can only be accessed from within the function.\n    # Trying to access this color variable outside will give you some problems.\n    # However, the global variable is still accessible from inside here.\n    print(color)\n    print(name)\n    # The name that is passed here is local and not the global variable name we see up there.\ngreeting(\"John\\n\\n\")",
        "detail": "Lesson 11.scope",
        "documentation": {}
    },
    {
        "label": "another",
        "kind": 2,
        "importPath": "Lesson 11.scope",
        "description": "Lesson 11.scope",
        "peekOfCode": "def another():\n    # In this case the color variable is in the parent scope (that is another).\n    color = \"Blue\"\n    # And this function is only available inside the another function and not the global scope.\n    def greeting(name):\n        print(color)\n        print(name)\n    greeting(\"Dave\")\nanother()\n# Like shown above you could have a nested function strictly because you only need that function within that function.",
        "detail": "Lesson 11.scope",
        "documentation": {}
    },
    {
        "label": "another1",
        "kind": 2,
        "importPath": "Lesson 11.scope",
        "description": "Lesson 11.scope",
        "peekOfCode": "def another1():\n    color = \"Blue\"\n    # When I create a count here, that is treated like a new variable and not a reassignment.\n    # count = 5\n    # print(count)\n    # You can access the global count but not modify it, it throws an error.\n    # count += 1\n    # print(count)\n    # To use the global value from above we use the global keyword.\n    global count",
        "detail": "Lesson 11.scope",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "Lesson 11.scope",
        "description": "Lesson 11.scope",
        "peekOfCode": "name = \"Dave\"\ncount = 1\n# Now we create a function that has local scope and this global variable will still be available there\ndef greeting(name):\n    color = \"Blue\"\n    # Local scope.\n    # In this case color can only be accessed from within the function.\n    # Trying to access this color variable outside will give you some problems.\n    # However, the global variable is still accessible from inside here.\n    print(color)",
        "detail": "Lesson 11.scope",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "Lesson 11.scope",
        "description": "Lesson 11.scope",
        "peekOfCode": "count = 1\n# Now we create a function that has local scope and this global variable will still be available there\ndef greeting(name):\n    color = \"Blue\"\n    # Local scope.\n    # In this case color can only be accessed from within the function.\n    # Trying to access this color variable outside will give you some problems.\n    # However, the global variable is still accessible from inside here.\n    print(color)\n    print(name)",
        "detail": "Lesson 11.scope",
        "documentation": {}
    },
    {
        "label": "parent_function",
        "kind": 2,
        "importPath": "Lesson 12.closure",
        "description": "Lesson 12.closure",
        "peekOfCode": "def parent_function(person):\n    coins = 3\n    def play_game():\n        nonlocal coins\n        coins -= 1\n        if(coins > 1):\n            print(\"\\n\" + person + \" has \" + str(coins) + \" coins left.\")\n        elif( coins == 1):\n            print(\"\\n\" + person + \" has \" + str(coins) + \" coin left.\")\n        else:",
        "detail": "Lesson 12.closure",
        "documentation": {}
    },
    {
        "label": "tommy",
        "kind": 5,
        "importPath": "Lesson 12.closure",
        "description": "Lesson 12.closure",
        "peekOfCode": "tommy = parent_function(\"Tommy\")\njenny = parent_function(\"Jenny\")\ntommy()\ntommy()\njenny()",
        "detail": "Lesson 12.closure",
        "documentation": {}
    },
    {
        "label": "jenny",
        "kind": 5,
        "importPath": "Lesson 12.closure",
        "description": "Lesson 12.closure",
        "peekOfCode": "jenny = parent_function(\"Jenny\")\ntommy()\ntommy()\njenny()",
        "detail": "Lesson 12.closure",
        "documentation": {}
    },
    {
        "label": "line01",
        "kind": 5,
        "importPath": "Lesson 2.welcome",
        "description": "Lesson 2.welcome",
        "peekOfCode": "line01 = \"******************************\"  # This is a header/footer\nline02 = \"*                            *\"  # We Re-use this\nline03 = \"*          WELCOME!          *\"\n# Starts with a blank line\nprint(\"\")\nprint(line01)\nprint(line02)\nprint(line03)\nprint(line02)\nprint(line01)",
        "detail": "Lesson 2.welcome",
        "documentation": {}
    },
    {
        "label": "line02",
        "kind": 5,
        "importPath": "Lesson 2.welcome",
        "description": "Lesson 2.welcome",
        "peekOfCode": "line02 = \"*                            *\"  # We Re-use this\nline03 = \"*          WELCOME!          *\"\n# Starts with a blank line\nprint(\"\")\nprint(line01)\nprint(line02)\nprint(line03)\nprint(line02)\nprint(line01)",
        "detail": "Lesson 2.welcome",
        "documentation": {}
    },
    {
        "label": "line03",
        "kind": 5,
        "importPath": "Lesson 2.welcome",
        "description": "Lesson 2.welcome",
        "peekOfCode": "line03 = \"*          WELCOME!          *\"\n# Starts with a blank line\nprint(\"\")\nprint(line01)\nprint(line02)\nprint(line03)\nprint(line02)\nprint(line01)",
        "detail": "Lesson 2.welcome",
        "documentation": {}
    },
    {
        "label": "meaning",
        "kind": 5,
        "importPath": "Lesson 3.operators",
        "description": "Lesson 3.operators",
        "peekOfCode": "meaning = 55\nprint(\"\")\n# if meaning > 10:\n#     print(\"Good Answer!\")\n# else:\n#     print(\"Bad Answer!\")\n# There's an even better solution to the if else statement\n# Just use a ternary operator.\nprint(\"Good Answer!\") if meaning > 10 else print(\"Bad Answer!\")",
        "detail": "Lesson 3.operators",
        "documentation": {}
    },
    {
        "label": "first",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "first = \"Shrey\"\nlast = \"Patel\"\n# print(type(first))\n# print(type(first) == str)\n# print(isinstance(first, str))\n# 2. Can also assign a string to a variable using the string constructor function.\nvada = str(\"pav\")\n# print(type(vada))\n# print(type(vada) == str)\n# print(isinstance(vada, str))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "last",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "last = \"Patel\"\n# print(type(first))\n# print(type(first) == str)\n# print(isinstance(first, str))\n# 2. Can also assign a string to a variable using the string constructor function.\nvada = str(\"pav\")\n# print(type(vada))\n# print(type(vada) == str)\n# print(isinstance(vada, str))\n# Concatenation",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "vada",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "vada = str(\"pav\")\n# print(type(vada))\n# print(type(vada) == str)\n# print(isinstance(vada, str))\n# Concatenation\nfullname = first + \" \" + last\n# print(fullname)\nfullname += \"!\"\n# print(fullname)\n# You can also take a different data type and cast it to a string.",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "fullname",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "fullname = first + \" \" + last\n# print(fullname)\nfullname += \"!\"\n# print(fullname)\n# You can also take a different data type and cast it to a string.\ndecade = str(1980)\n# print(type(decade))\n# Multiple lines\nmultiline = \"\"\"\nKem Cho ?",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "decade",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "decade = str(1980)\n# print(type(decade))\n# Multiple lines\nmultiline = \"\"\"\nKem Cho ?\nMajama?\n                        Ha ha Tame bolo\nJovo ne, Majama!\n\"\"\"\n# print(multiline)",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "multiline",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "multiline = \"\"\"\nKem Cho ?\nMajama?\n                        Ha ha Tame bolo\nJovo ne, Majama!\n\"\"\"\n# print(multiline)\n# Moving on to escaping special characters in Python Strings\n# \\  = This backslash escapes the next character after it.\n# \\t = This is used to get a tab.",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "sentence",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "sentence = \"I'm back at work!\\tHey!\\n\\nWhere's this at\\\\located?\"\n# print(sentence)\n# String Methods\n# print(first)\n# print(first.lower())\n# print(first.upper())\n# print(first)\n# print(multiline.title())  # This will be used to capitalize every word's first letter\n# print(multiline.replace(\"Majama\", \"Barobar\"))\n# When creating a string, all the whitespace characters also account for its length.",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "title",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "title = \"menu\".upper()\nprint(title.center(20, \"=\"))\nprint(\"Coffee \".ljust(16, \".\") + \"$4\".rjust(4))\nprint(\"Croissant \".ljust(16, \".\") + \"$3\".rjust(4))\nprint(\"Juice \".ljust(16, \".\") + \"$1\".rjust(4))\nprint(\" \")\n# String index values\nprint(\n    first[1]\n)  # This does not give you the first letter of my name, instead it gives you the second letter because indexing in python starts at 0.",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "myvalue",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "myvalue = True\nx = bool(False)  # This is the constructor method to create a Boolean variable.\nprint(type(x))\nprint(isinstance(x, bool))\nprint(\" \")\n# Let's move on to numeric data types\n# Integer\nprice = 100\nbest_price = int(80)\nprint(type(price))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "x = bool(False)  # This is the constructor method to create a Boolean variable.\nprint(type(x))\nprint(isinstance(x, bool))\nprint(\" \")\n# Let's move on to numeric data types\n# Integer\nprice = 100\nbest_price = int(80)\nprint(type(price))\nprint(isinstance(best_price, int))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "price",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "price = 100\nbest_price = int(80)\nprint(type(price))\nprint(isinstance(best_price, int))\n# Float Type - Has a Decimal\ngpa = 3.89\ny = float(1.62)\nprint(type(gpa))\n# Complex Type\ncomp_value = 5 + 3j",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "best_price",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "best_price = int(80)\nprint(type(price))\nprint(isinstance(best_price, int))\n# Float Type - Has a Decimal\ngpa = 3.89\ny = float(1.62)\nprint(type(gpa))\n# Complex Type\ncomp_value = 5 + 3j\nprint(type(comp_value))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "gpa",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "gpa = 3.89\ny = float(1.62)\nprint(type(gpa))\n# Complex Type\ncomp_value = 5 + 3j\nprint(type(comp_value))\nprint(comp_value.real)\nprint(comp_value.imag)\n# Built-in functions for numbers\nprint(abs(gpa))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "y = float(1.62)\nprint(type(gpa))\n# Complex Type\ncomp_value = 5 + 3j\nprint(type(comp_value))\nprint(comp_value.real)\nprint(comp_value.imag)\n# Built-in functions for numbers\nprint(abs(gpa))\nprint(round(gpa))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "comp_value",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "comp_value = 5 + 3j\nprint(type(comp_value))\nprint(comp_value.real)\nprint(comp_value.imag)\n# Built-in functions for numbers\nprint(abs(gpa))\nprint(round(gpa))\nprint(round(gpa, 1))\nprint(math.pi)\nprint(math.sqrt(81))",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "zipcode",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "zipcode = \"15228\"\nzip_value = int(zipcode)\nprint(type(zip_value))\n# This can throw an error if you try to cast an incorrect value to int.\nzip_value = int(\"Nairobi\")",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "zip_value",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "zip_value = int(zipcode)\nprint(type(zip_value))\n# This can throw an error if you try to cast an incorrect value to int.\nzip_value = int(\"Nairobi\")",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "zip_value",
        "kind": 5,
        "importPath": "Lesson 4.dataTypes",
        "description": "Lesson 4.dataTypes",
        "peekOfCode": "zip_value = int(\"Nairobi\")",
        "detail": "Lesson 4.dataTypes",
        "documentation": {}
    },
    {
        "label": "RPS",
        "kind": 6,
        "importPath": "Lesson 5.rps",
        "description": "Lesson 5.rps",
        "peekOfCode": "class RPS(Enum):\n    ROCK = 1\n    PAPER = 2\n    SCISSORS = 3\n# Different ways to check Enums:\n# print(RPS(2))\n# print(RPS.ROCK)\n# print(RPS[\"ROCK\"])\n# print(RPS.ROCK.value)\n# sys.exit()",
        "detail": "Lesson 5.rps",
        "documentation": {}
    },
    {
        "label": "player_choice",
        "kind": 5,
        "importPath": "Lesson 5.rps",
        "description": "Lesson 5.rps",
        "peekOfCode": "player_choice = input(\"Enter...\\n1 for Rock 🪨, \\n2 for Paper 📄, \\nor \\n3 for Scissors ✂️:\\n\\n\")\nplayer = int(player_choice)\n# Let's introduce some control-flow statements\nif player < 1 or player >3:\n    sys.exit(\"Please enter a valid choice!\") # This will exit the program but still display the message given in brackets.\ncomputer_choice = random.choice(\"123\")\ncomputer = int(computer_choice)\nprint(\"\")\nprint(\"You chose \" + str(RPS(player)).replace(\"RPS.\", \"\") + \".\")\nprint(\"Python chose \" + str(RPS(computer)).replace(\"RPS.\", \"\") + \".\")",
        "detail": "Lesson 5.rps",
        "documentation": {}
    },
    {
        "label": "player",
        "kind": 5,
        "importPath": "Lesson 5.rps",
        "description": "Lesson 5.rps",
        "peekOfCode": "player = int(player_choice)\n# Let's introduce some control-flow statements\nif player < 1 or player >3:\n    sys.exit(\"Please enter a valid choice!\") # This will exit the program but still display the message given in brackets.\ncomputer_choice = random.choice(\"123\")\ncomputer = int(computer_choice)\nprint(\"\")\nprint(\"You chose \" + str(RPS(player)).replace(\"RPS.\", \"\") + \".\")\nprint(\"Python chose \" + str(RPS(computer)).replace(\"RPS.\", \"\") + \".\")\nprint(\"\")",
        "detail": "Lesson 5.rps",
        "documentation": {}
    },
    {
        "label": "computer_choice",
        "kind": 5,
        "importPath": "Lesson 5.rps",
        "description": "Lesson 5.rps",
        "peekOfCode": "computer_choice = random.choice(\"123\")\ncomputer = int(computer_choice)\nprint(\"\")\nprint(\"You chose \" + str(RPS(player)).replace(\"RPS.\", \"\") + \".\")\nprint(\"Python chose \" + str(RPS(computer)).replace(\"RPS.\", \"\") + \".\")\nprint(\"\")\nif player == 1 and computer ==3:\n    print(\"🎉 You Win!\")\nelif player == 2 and computer ==1:\n    print(\"🎉 You Win!\")",
        "detail": "Lesson 5.rps",
        "documentation": {}
    },
    {
        "label": "computer",
        "kind": 5,
        "importPath": "Lesson 5.rps",
        "description": "Lesson 5.rps",
        "peekOfCode": "computer = int(computer_choice)\nprint(\"\")\nprint(\"You chose \" + str(RPS(player)).replace(\"RPS.\", \"\") + \".\")\nprint(\"Python chose \" + str(RPS(computer)).replace(\"RPS.\", \"\") + \".\")\nprint(\"\")\nif player == 1 and computer ==3:\n    print(\"🎉 You Win!\")\nelif player == 2 and computer ==1:\n    print(\"🎉 You Win!\")\nelif player == 3 and computer ==2:",
        "detail": "Lesson 5.rps",
        "documentation": {}
    },
    {
        "label": "users",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "users = [\"Jack\", \"Sara\", \"Jacob\"]\ndata = [\"John\", 58, True]\nempty_data = []\na_list = list([1, \"James\", True]) # Even though it's kinda pointless but it's there as a method.\n# This checks whether an element actually exists in a list and returns a Boolean value.\n# print(\"Jack\" in users)\n# This uses the index of an element to retrieve it.\n# print(users[1])\n# print(users[-1])\n# This is used to check the index of the given item in an list.",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "data = [\"John\", 58, True]\nempty_data = []\na_list = list([1, \"James\", True]) # Even though it's kinda pointless but it's there as a method.\n# This checks whether an element actually exists in a list and returns a Boolean value.\n# print(\"Jack\" in users)\n# This uses the index of an element to retrieve it.\n# print(users[1])\n# print(users[-1])\n# This is used to check the index of the given item in an list.\n# print(users.index(\"Sara\")) ",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "empty_data",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "empty_data = []\na_list = list([1, \"James\", True]) # Even though it's kinda pointless but it's there as a method.\n# This checks whether an element actually exists in a list and returns a Boolean value.\n# print(\"Jack\" in users)\n# This uses the index of an element to retrieve it.\n# print(users[1])\n# print(users[-1])\n# This is used to check the index of the given item in an list.\n# print(users.index(\"Sara\")) \n# You can also use ranges to return elements in a list.",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "a_list",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "a_list = list([1, \"James\", True]) # Even though it's kinda pointless but it's there as a method.\n# This checks whether an element actually exists in a list and returns a Boolean value.\n# print(\"Jack\" in users)\n# This uses the index of an element to retrieve it.\n# print(users[1])\n# print(users[-1])\n# This is used to check the index of the given item in an list.\n# print(users.index(\"Sara\")) \n# You can also use ranges to return elements in a list.\n# print(users[0:2])",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "users[2:2]",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "users[2:2] = [\"Eliud\", \"Chiran\"]\n# print(users)\n# You can also replace items in a list using a range and the last item in the range will stay the same.\nusers[1:3] = [\"Chan\", \"Jain\"]\n# print(users)\n# This is how we remove items from a list.\nusers.remove(\"Bob\")\n# print(users)\n# We can remove the last item in the list using the pop method.\n# print(users.pop())",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "users[1:3]",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "users[1:3] = [\"Chan\", \"Jain\"]\n# print(users)\n# This is how we remove items from a list.\nusers.remove(\"Bob\")\n# print(users)\n# We can remove the last item in the list using the pop method.\n# print(users.pop())\n# print(users)\n# We can also just use the del keyword and the user's index to chuck them out of the list.\ndel users[1]",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "users[1:2]",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "users[1:2] = [\"alan\"]\nusers.sort() # This method usually sorts in Ascending order but the Capital letter words are given priority when sorting.\n# print(users)\n# Let's give alan the justice he deserves when sorting by introducing an argument that will allow lowercase names to be sorted accordingly.\nusers.sort(key=str.lower)\n# print(users)\n# Let's look at number Arrays/Lists and their associated functions.\nnums = [5,96,2,75,23,15]\nnums.reverse() # This function literally takes the array and flips the positions the elements.\nprint(nums)",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "nums = [5,96,2,75,23,15]\nnums.reverse() # This function literally takes the array and flips the positions the elements.\nprint(nums)\n# nums.sort(reverse=True) \n# This function on the other hand will not reverse it but it will sort in descending order.\n# print(nums)\n# In order to keep the original list and sort it for our purposes we can do the following...\n# We're making use of the global sorted function.\nprint(sorted(nums, reverse=True))\nprint(nums)",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "numscopy",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "numscopy = nums.copy()\nprint(numscopy)\n# No. 2 -> Use the list constructor.\nnumscopy1 = list(nums)\nprint(numscopy1)\n# No. 3 -> Use the list range without numbers.\nnumscopy2 = nums[:]\nprint(numscopy2)\n# -------------Tuples-------------\n# Tuples are very much like lists, except the data in them does not change and the order of that data does not change.",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "numscopy1",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "numscopy1 = list(nums)\nprint(numscopy1)\n# No. 3 -> Use the list range without numbers.\nnumscopy2 = nums[:]\nprint(numscopy2)\n# -------------Tuples-------------\n# Tuples are very much like lists, except the data in them does not change and the order of that data does not change.\n# Constructor method\ntuple1 = tuple((1, \"Sam\", False))\nprint(tuple1)",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "numscopy2",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "numscopy2 = nums[:]\nprint(numscopy2)\n# -------------Tuples-------------\n# Tuples are very much like lists, except the data in them does not change and the order of that data does not change.\n# Constructor method\ntuple1 = tuple((1, \"Sam\", False))\nprint(tuple1)\n# Normal Method\ntuple2 = (1,5,9,65,2,78,64,23,10,5,5,5,5,5)\nprint(tuple2)",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "tuple1",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "tuple1 = tuple((1, \"Sam\", False))\nprint(tuple1)\n# Normal Method\ntuple2 = (1,5,9,65,2,78,64,23,10,5,5,5,5,5)\nprint(tuple2)\n# As mentioned above, tuples cannot be changed. Therefore, what we can do is copy a tuple and perform the action on it.\n# Create a list from the tuple.\ntuplecopy = list(tuple1)\ntuplecopy.append(\"Sara\")\ntuple3 = tuple(tuplecopy)",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "tuple2",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "tuple2 = (1,5,9,65,2,78,64,23,10,5,5,5,5,5)\nprint(tuple2)\n# As mentioned above, tuples cannot be changed. Therefore, what we can do is copy a tuple and perform the action on it.\n# Create a list from the tuple.\ntuplecopy = list(tuple1)\ntuplecopy.append(\"Sara\")\ntuple3 = tuple(tuplecopy)\nprint(tuple3)\n# What we have been doing above is creating a tuple by \"Packing\" it.\n# Now we unpack it into different variables.",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "tuplecopy",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "tuplecopy = list(tuple1)\ntuplecopy.append(\"Sara\")\ntuple3 = tuple(tuplecopy)\nprint(tuple3)\n# What we have been doing above is creating a tuple by \"Packing\" it.\n# Now we unpack it into different variables.\n(one, *two, three) = tuple2 # The asterisk is to assign the remainder of the items to one variable as a list.\nprint(one)\nprint(two)\nprint(three)",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "tuple3",
        "kind": 5,
        "importPath": "Lesson 6.lists",
        "description": "Lesson 6.lists",
        "peekOfCode": "tuple3 = tuple(tuplecopy)\nprint(tuple3)\n# What we have been doing above is creating a tuple by \"Packing\" it.\n# Now we unpack it into different variables.\n(one, *two, three) = tuple2 # The asterisk is to assign the remainder of the items to one variable as a list.\nprint(one)\nprint(two)\nprint(three)\n# The tuple has methods available to it\n# Like this count method when passed an argument like a number will count how many instanced=s if that number are there in that tuple.",
        "detail": "Lesson 6.lists",
        "documentation": {}
    },
    {
        "label": "band",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band = {\n    \"Vocals\": \"Plant\",\n    \"Guitar\": \"Page\"\n}\n# Creating Dictionaries with the constructor method.\nband2 = dict(Vocals=\"Plant\", Guitar=\"Page\")\nprint(band)\nprint(band2)\nprint(type(band))\nprint(len(band2))",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band2",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band2 = dict(Vocals=\"Plant\", Guitar=\"Page\")\nprint(band)\nprint(band2)\nprint(type(band))\nprint(len(band2))\n# Accessing items in a dictionary.\nprint(band[\"Vocals\"])\nprint(band.get(\"Guitar\"))\n# To list all the keys we will.\nprint(band.keys())",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band[\"Vocals\"]",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band[\"Vocals\"] = \"Coverdale\"\nband.update({\"bass\": \"JPJ\"})\nprint(band)\n# After adding now we remove.\n# Using the pop method will usually return a value that we removed from the dictionary.\nprint(band.pop(\"bass\"))\nprint(band)\nband[\"Drums\"] = \"Bonham\"\nprint(band)\n# With this we will get the last item in the dictionary but it will return a key:value pair tuple and not a value.",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band[\"Drums\"]",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band[\"Drums\"] = \"Bonham\"\nprint(band)\n# With this we will get the last item in the dictionary but it will return a key:value pair tuple and not a value.\nprint(band.popitem())\nprint(band)\n# To delete and clear.\nband[\"Drums\"] = \"Bonham\"\ndel band[\"Drums\"]\nprint(band)\n# To completely clear a dictionary we use the clear method.",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band[\"Drums\"]",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band[\"Drums\"] = \"Bonham\"\ndel band[\"Drums\"]\nprint(band)\n# To completely clear a dictionary we use the clear method.\nband2.clear()\nprint(band2)\n# We can also delete the entire dictionary.\ndel band2\n# print(band2)\n# Next, Let's copy some dictionaries.",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band2",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band2 = band.copy()\nprint(\"\\nThe Right Way!\")\nband2[\"Drums\"] = \"Bonham\"\nprint(band2)\nprint(band)\n# If you like complicating your life use the constructor function, still works.\nband3 = dict(band)\nprint(\"\\nStill The Right Way!\")\nband3[\"Drums\"] = \"Koko\"\nprint(band3)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band2[\"Drums\"]",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band2[\"Drums\"] = \"Bonham\"\nprint(band2)\nprint(band)\n# If you like complicating your life use the constructor function, still works.\nband3 = dict(band)\nprint(\"\\nStill The Right Way!\")\nband3[\"Drums\"] = \"Koko\"\nprint(band3)\nprint(band)\n# Another interesting concept to look at is the Nested Dictionaries.",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band3",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band3 = dict(band)\nprint(\"\\nStill The Right Way!\")\nband3[\"Drums\"] = \"Koko\"\nprint(band3)\nprint(band)\n# Another interesting concept to look at is the Nested Dictionaries.\n# Basically, the value for a key will be another dictionary in this case.\nmember1 = {\n    \"name\": \"Plant\",\n    \"instrument\": \"Vocals\"",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band3[\"Drums\"]",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band3[\"Drums\"] = \"Koko\"\nprint(band3)\nprint(band)\n# Another interesting concept to look at is the Nested Dictionaries.\n# Basically, the value for a key will be another dictionary in this case.\nmember1 = {\n    \"name\": \"Plant\",\n    \"instrument\": \"Vocals\"\n}\nmember2 = {",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "member1",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "member1 = {\n    \"name\": \"Plant\",\n    \"instrument\": \"Vocals\"\n}\nmember2 = {\n    \"name\": \"Page\",\n    \"instrument\": \"Guitar\"\n}\nband4 = {\n    \"member1\": member1,",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "member2",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "member2 = {\n    \"name\": \"Page\",\n    \"instrument\": \"Guitar\"\n}\nband4 = {\n    \"member1\": member1,\n    \"member2\": member2\n}\nprint(\"\\nLet's look at nested dictionaries. \\nVoila!\")\nprint(band4)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "band4",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "band4 = {\n    \"member1\": member1,\n    \"member2\": member2\n}\nprint(\"\\nLet's look at nested dictionaries. \\nVoila!\")\nprint(band4)\n# How can you access values in a nested dictionary?\nprint(band4[\"member1\"][\"name\"])\n# Python Sets\nnums = {1, 2, 3, 4}",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "nums = {1, 2, 3, 4}\nnums2 = set((1, 2, 3, 4))\nprint(nums)\nprint(nums2)\nprint(type(nums2))\nprint(len(nums2))\n# The advantage of a set is that no duplicates are allowed.\nnums = {1, 3, 2, 3, 4, 2}\nprint(nums)  # Will not throw an error, just ignores the duplicates.\n# The True value is a dupe of 1 and the False value is a dupe of 0.",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "nums2",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "nums2 = set((1, 2, 3, 4))\nprint(nums)\nprint(nums2)\nprint(type(nums2))\nprint(len(nums2))\n# The advantage of a set is that no duplicates are allowed.\nnums = {1, 3, 2, 3, 4, 2}\nprint(nums)  # Will not throw an error, just ignores the duplicates.\n# The True value is a dupe of 1 and the False value is a dupe of 0.\nnums = {1, True, 2, False, 3, 4, 0}",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "nums = {1, 3, 2, 3, 4, 2}\nprint(nums)  # Will not throw an error, just ignores the duplicates.\n# The True value is a dupe of 1 and the False value is a dupe of 0.\nnums = {1, True, 2, False, 3, 4, 0}\nprint(nums)\n# You can also check if a value is in a set.\nprint(4 in nums)\n# The funny thing about a set is you cannot reference an item in the set using an index (like in lists) or using a key (like in dictionaries).\n# Adding values to a set\nnums.add(9)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "nums = {1, True, 2, False, 3, 4, 0}\nprint(nums)\n# You can also check if a value is in a set.\nprint(4 in nums)\n# The funny thing about a set is you cannot reference an item in the set using an index (like in lists) or using a key (like in dictionaries).\n# Adding values to a set\nnums.add(9)\nprint(nums)\n# Adding elements from another set to our set.\nmorenums = {5, 6, 7, 8}",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "morenums",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "morenums = {5, 6, 7, 8}\nnums.update(morenums)\nprint(nums)\n# Fun Fact: You can also use the update method with lists, Tuples and Dictionaries.\n# Merge two sets to create a new set.\none = {1, 2, 3}\ntwo = {4, 5, 6}\nthenewset = one.union(two)\nprint(thenewset)\n# Keep only the duplicates",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "one",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "one = {1, 2, 3}\ntwo = {4, 5, 6}\nthenewset = one.union(two)\nprint(thenewset)\n# Keep only the duplicates\none = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.intersection_update(two) # This one modifies the first set - one.\nthe_new_set = one.intersection(two) # This returns the similarities between the set and assigns it to a new set.\nprint(one)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "two",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "two = {4, 5, 6}\nthenewset = one.union(two)\nprint(thenewset)\n# Keep only the duplicates\none = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.intersection_update(two) # This one modifies the first set - one.\nthe_new_set = one.intersection(two) # This returns the similarities between the set and assigns it to a new set.\nprint(one)\nprint(the_new_set)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "thenewset",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "thenewset = one.union(two)\nprint(thenewset)\n# Keep only the duplicates\none = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.intersection_update(two) # This one modifies the first set - one.\nthe_new_set = one.intersection(two) # This returns the similarities between the set and assigns it to a new set.\nprint(one)\nprint(the_new_set)\n# Keep everything except the duplicates",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "one",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "one = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.intersection_update(two) # This one modifies the first set - one.\nthe_new_set = one.intersection(two) # This returns the similarities between the set and assigns it to a new set.\nprint(one)\nprint(the_new_set)\n# Keep everything except the duplicates\none = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.symmetric_difference_update(two)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "two",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "two = {2, 3, 4, 5, 6}\none.intersection_update(two) # This one modifies the first set - one.\nthe_new_set = one.intersection(two) # This returns the similarities between the set and assigns it to a new set.\nprint(one)\nprint(the_new_set)\n# Keep everything except the duplicates\none = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.symmetric_difference_update(two)\nprint(one)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "the_new_set",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "the_new_set = one.intersection(two) # This returns the similarities between the set and assigns it to a new set.\nprint(one)\nprint(the_new_set)\n# Keep everything except the duplicates\none = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.symmetric_difference_update(two)\nprint(one)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "one",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "one = {1, 2, 3}\ntwo = {2, 3, 4, 5, 6}\none.symmetric_difference_update(two)\nprint(one)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "two",
        "kind": 5,
        "importPath": "Lesson 7.dictionaries",
        "description": "Lesson 7.dictionaries",
        "peekOfCode": "two = {2, 3, 4, 5, 6}\none.symmetric_difference_update(two)\nprint(one)",
        "detail": "Lesson 7.dictionaries",
        "documentation": {}
    },
    {
        "label": "value",
        "kind": 5,
        "importPath": "Lesson 8.loops",
        "description": "Lesson 8.loops",
        "peekOfCode": "value = 1\n# while value <= 10:\n#     print(value)\n#     # To get out of the loop using another condition we can.\n#     if value == 5:\n#         break\n#     value+=1\n\"\"\"\nwhile value <= 10:\n    value+=1",
        "detail": "Lesson 8.loops",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 5,
        "importPath": "Lesson 8.loops",
        "description": "Lesson 8.loops",
        "peekOfCode": "names = [\"Dave\", \"Jocelyn\", \"Sara\", \"Maki\", \"Jaya\", \"Anita\", \"Celia\"]\nactions = [\"Works\", \"Eats\", \"Sleeps\"]\n# for name in names:\n#     for action in actions:\n#         print(name + \" \" + action + \".\")\n#     print(\"\")\nfor action in actions:\n    for name in names:\n        print(name + \" \" + action + \".\")\n    print(\"\")",
        "detail": "Lesson 8.loops",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "Lesson 8.loops",
        "description": "Lesson 8.loops",
        "peekOfCode": "actions = [\"Works\", \"Eats\", \"Sleeps\"]\n# for name in names:\n#     for action in actions:\n#         print(name + \" \" + action + \".\")\n#     print(\"\")\nfor action in actions:\n    for name in names:\n        print(name + \" \" + action + \".\")\n    print(\"\")",
        "detail": "Lesson 8.loops",
        "documentation": {}
    },
    {
        "label": "RPS",
        "kind": 6,
        "importPath": "Lesson 8.rp2",
        "description": "Lesson 8.rp2",
        "peekOfCode": "class RPS(Enum):\n    ROCK = 1\n    PAPER = 2\n    SCISSORS = 3\n# Different ways to check Enums:\n# print(RPS(2))\n# print(RPS.ROCK)\n# print(RPS[\"ROCK\"])\n# print(RPS.ROCK.value)\n# sys.exit()",
        "detail": "Lesson 8.rp2",
        "documentation": {}
    },
    {
        "label": "playagain",
        "kind": 5,
        "importPath": "Lesson 8.rp2",
        "description": "Lesson 8.rp2",
        "peekOfCode": "playagain = True\nwhile playagain:\n    # Now we start coding the Rock-Paper-Scissors game.\n    print(\"\")\n    player_choice = input(\"Enter...\\n1 for Rock 🪨, \\n2 for Paper 📄, \\nor \\n3 for Scissors ✂️:\\n\\n\")\n    player = int(player_choice)\n    # Let's introduce some control-flow statements\n    if player < 1 or player >3:\n        sys.exit(\"Please enter a valid choice!\") # This will exit the program but still display the message given in brackets.\n    computer_choice = random.choice(\"123\")",
        "detail": "Lesson 8.rp2",
        "documentation": {}
    },
    {
        "label": "hello",
        "kind": 2,
        "importPath": "Lesson 9.functions",
        "description": "Lesson 9.functions",
        "peekOfCode": "def hello():\n    print(\"Kem Cho?\")\n# So we need to call it.\n# hello()\n# Next, we can create a function that takes parameters or values.\n# I have assigned a default values to the nums incase a value is not provided.\ndef sum(num1 = 0, num2 = 0):\n    if (type(num1) is not int or type(num2) is not int):\n        return # This is what we call an early return and it prevents the coming lines from executing. It just returns none.\n        # return 0 to make it return a zero.",
        "detail": "Lesson 9.functions",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 2,
        "importPath": "Lesson 9.functions",
        "description": "Lesson 9.functions",
        "peekOfCode": "def sum(num1 = 0, num2 = 0):\n    if (type(num1) is not int or type(num2) is not int):\n        return # This is what we call an early return and it prevents the coming lines from executing. It just returns none.\n        # return 0 to make it return a zero.\n    return num1+num2\n# When we call this function and pass it values, these now become arguments.\n# Fun Fact: The easiest way to differentiate between parameters and arguments is that \n# parameters never change, but arguments keep changing with every function call.\n# The argument is the actual data passed in when the function is called.\ntotal = sum()",
        "detail": "Lesson 9.functions",
        "documentation": {}
    },
    {
        "label": "multiple_items",
        "kind": 2,
        "importPath": "Lesson 9.functions",
        "description": "Lesson 9.functions",
        "peekOfCode": "def multiple_items(*args):\n    print(args)\n    print(type(args))\n# When the single asterisk is used it returns a tuple.\nmultiple_items(\"Donna\", 2, True)\n# If you want to assign names to the arguments then you can use keyword arguments\ndef multi_named_items(**kwargs):\n    print(kwargs)\n    print(type(kwargs))\nmulti_named_items(First = \"Donna\", Last = \"Anderson\")",
        "detail": "Lesson 9.functions",
        "documentation": {}
    },
    {
        "label": "multi_named_items",
        "kind": 2,
        "importPath": "Lesson 9.functions",
        "description": "Lesson 9.functions",
        "peekOfCode": "def multi_named_items(**kwargs):\n    print(kwargs)\n    print(type(kwargs))\nmulti_named_items(First = \"Donna\", Last = \"Anderson\")\n# The result from this is a dictionary and i think it will be much more useful than a tuple",
        "detail": "Lesson 9.functions",
        "documentation": {}
    },
    {
        "label": "total",
        "kind": 5,
        "importPath": "Lesson 9.functions",
        "description": "Lesson 9.functions",
        "peekOfCode": "total = sum()\nprint(total)\n# Sometimes we can have a function where we don't know the number of arguments that will be passed.\n# So we use the args keyword with an asterisk.\ndef multiple_items(*args):\n    print(args)\n    print(type(args))\n# When the single asterisk is used it returns a tuple.\nmultiple_items(\"Donna\", 2, True)\n# If you want to assign names to the arguments then you can use keyword arguments",
        "detail": "Lesson 9.functions",
        "documentation": {}
    },
    {
        "label": "multi_named_items(First",
        "kind": 5,
        "importPath": "Lesson 9.functions",
        "description": "Lesson 9.functions",
        "peekOfCode": "multi_named_items(First = \"Donna\", Last = \"Anderson\")\n# The result from this is a dictionary and i think it will be much more useful than a tuple",
        "detail": "Lesson 9.functions",
        "documentation": {}
    }
]